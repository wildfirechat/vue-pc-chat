/*
 * Copyright (c) 2020 WildFireChat. All rights reserved.
 */

// import proto from 'node-loader!../../../marswrapper.node';
import Message from '../messages/message';
import Conversation from '../model/conversation';
import ConversationInfo from '../model/conversationInfo';
import EventType from '../client/wfcEvent'
import UserInfo from '../model/userInfo';
import NullUserInfo from '../model/nullUserInfo';
import NullGroupInfo from '../model/nullGroupInfo';
import GroupInfo from '../model/groupInfo';
import GroupMember from '../model/groupMember';
import UserSettingScope from '../client/userSettingScope';
import AddGroupMemberNotification from '../messages/notification/addGroupMemberNotification';
import MessageConfig from '../client/messageConfig';
import UnreadCount from '../model/unreadCount';
import ConversationSearchResult from '../model/conversationSearchResult';
import MessageStatus from '../messages/messageStatus';
import GroupSearchResult from '../model/groupSearchResult';
import FriendRequest from '../model/friendRequest';
import ChatRoomMemberInfo from '../model/chatRoomMemberInfo';
import ChannelInfo from '../model/channelInfo';
import ConnectionStatus from '../client/connectionStatus';
import Long from 'long';
import Config from "../../config";
import ChatRoomInfo from "../model/chatRoomInfo";
import ReadEntry from "../model/readEntry";
import {promises as fs} from 'fs';
import FileRecord from "../model/fileRecord";
import MediaMessageContent from "../messages/mediaMessageContent";
import MarkUnreadMessageContent from "../messages/markUnreadMessageContent";
import {gt, stringValue} from "../util/longUtil";
import NullChannelInfo from "../model/NullChannelInfo";
import UserOnlineState from "../model/userOnlineState";
import UserCustomState from "../model/userCustomState";
import UserClientState from "../model/userClientState";
import {ipcRenderer} from "../../platform";
import SecretChatInfo from "../model/secretChatInfo";
import ConversationType from "../model/conversationType";
import ChannelMenu from "../model/channelMenu";
import protoProxy from "./proto_renderer_proxy";
import TextMessageContent from "../messages/textMessageContent";
import FileMessageContent from "../messages/fileMessageContent";
import ImageMessageContent from "../messages/imageMessageContent";
import os from "os";
import path from "path";


/**
 * java long 类型在 javascript 类型的映射说明:
 * 字段messageUid 对应 Long 对象
 * 其他 long 类型的变量 对应 number
 *
 * node addon 和 proto.min.js 之间 java long类型数据的传递
 * 双向传递时，都需 java long 类型的数据转换成字符串传递
 *
 */
class WfcImpl {
    connectionStatus = 0;
    userId = '';
    token = '';
    users = new Map();
    groups = new Map();
    isLogined = false;
    needPreloadDefaultData = false;

    eventEmitter;

    uploadingMap = new Map();

    onConnectionChanged(status) {
        if (!self.isLogined && status === ConnectionStatus.ConnectionStatusConnected) {
            self.isLogined = true;
        }
        if (status === ConnectionStatus.ConnectionStatusConnected) {
            if (self.needPreloadDefaultData) {
                // 预加载数据
                // 拉取会话相关用户、群信息
                // 自己的用户信息
                // 获取所有好友、好友请求的用户信息
                let estimatedTime = self._preloadDefaultData();
                console.log('to load default data', estimatedTime);
                setTimeout(() => {
                    self.connectionStatus = status;
                    self.eventEmitter.emit(EventType.ConnectionStatusChanged, status);
                }, estimatedTime)
            } else {
                self.connectionStatus = status;
                self.eventEmitter.emit(EventType.ConnectionStatusChanged, status);
            }
        } else {
            self.connectionStatus = status;
            self.eventEmitter.emit(EventType.ConnectionStatusChanged, status);
        }
        console.log('connection status changed', status);
        if (self.isLogined && (status === ConnectionStatus.ConnectionStatusSecretKeyMismatch || status === ConnectionStatus.ConnectionStatusRejected)) {
            self.disconnect();
        }

        if (status === ConnectionStatus.ConnectionStatusConnected) {
            if (self.isEnableSecretChat() && self.isUserEnableSecretChat()) {
                ipcRenderer.send('start-secret-server', {port: Config.SECRET_CHAT_MEDIA_DECODE_SERVER_PORT});
            }
            if (Config.OPEN_PLATFORM_WORK_SPACE_URL) {
                ipcRenderer.send('start-op-server', {port: Config.OPEN_PLATFORM_SERVE_PORT});
            }
        }
    }

    onConnectToServer(host, ip, port) {
        console.log('connect to server', host, ip, port);
        self.eventEmitter.emit(EventType.ConnectToServer, host, ip, port);
    }

    onReceiveMessage(messages, hasMore) {
        if (!self.isLogined) {
            return;
        }
        // receiving
        if (self.connectionStatus === 2) {
            return;
        }

        var msgs = JSON.parse(messages);
        msgs.forEach(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg.messageContent instanceof MarkUnreadMessageContent && msg.from === self.userId) {
                let markMsg = msg.messageContent;
                let conversation = msg.conversation;
                protoProxy.invoke('setLastReceivedMessageUnRead', JSON.stringify(conversation), stringValue(markMsg.messageUid), stringValue(markMsg.timestamp));
            }
            if (msg) {
                self.eventEmitter.emit(EventType.ReceiveMessage, msg);
            }
        });
    }

    onConferenceEvent(event) {
        self.eventEmitter.emit(EventType.ConferenceEvent, event)
    }

    onOnlineEvent(event) {
        let userOnlineStates = self._parseUserOnlineState(event);
        self.eventEmitter.emit(EventType.UserOnlineEvent, userOnlineStates);
    }

    _parseUserOnlineState(userOnlineStateStr) {
        let userOnlineStates = [];
        let states = JSON.parse(userOnlineStateStr);
        states.forEach(s => {
            let userOnlineState = new UserOnlineState();
            userOnlineState.userId = s.userId;
            userOnlineState.customState = new UserCustomState();
            userOnlineState.customState.state = s.customState;
            userOnlineState.customState.text = s.customText;
            userOnlineState.clientStates = [];

            if (s.states) {
                s.states.forEach(ss => {
                    let clientState = new UserClientState();
                    clientState.state = ss.state;
                    clientState.platform = ss.platform;
                    clientState.lastSeen = Long.fromValue(ss.lastSeen);
                    userOnlineState.clientStates.push(clientState)
                })
            }
            userOnlineStates.push(userOnlineState);
        })
        return userOnlineStates;
    }

    onGroupInfoUpdate(groupListIds) {
        if (!self.isLogined) {
            return;
        }

        let groupIdArray = JSON.parse(groupListIds);
        let groupInfos = self.getGroupInfos(groupIdArray, false);
        groupInfos.forEach(gi => {
            self.groups.set(gi.target, gi);
        })

        self.eventEmitter.emit(EventType.GroupInfosUpdate, groupInfos);
    }

    onChannelInfoUpdate(channelListIds) {
        if (!self.isLogined) {
            return;
        }
        let channelIdArray = JSON.parse(channelListIds);

        let channelInfos = [];
        channelIdArray.forEach((channelId => {
            channelInfos.push(self.getChannelInfo(channelId, false));
        }))
        self.eventEmitter.emit(EventType.ChannelInfosUpdate, channelInfos)
    }

    onGroupMemberUpdateListener(groupId, groupMembersStr) {
        if (!self.isLogined) {
            return;
        }
        let members = [];
        let memberIds = [];
        let arr = JSON.parse(groupMembersStr);
        arr.forEach(e => {
            members.push(Object.assign(new GroupMember(), e));
            memberIds.push(e.memberId)
        });
        self._preloadGroupMemberUserInfos(memberIds);

        self.eventEmitter.emit(EventType.GroupMembersUpdate, groupId, members);
    }

    onSettingUpdate() {
        if (!self.isLogined) {
            return;
        }
        // TODO 具体更新的信息
        self.eventEmitter.emit(EventType.SettingUpdate);
    }

    onRecallMessage(operatorUid, messageUid) {
        if (!self.isLogined) {
            return;
        }
        self.eventEmitter.emit(EventType.RecallMessage, operatorUid, Long.fromValue(messageUid));
    }

    onDeleteRemoteMessage(messageUid) {
        if (!self.isLogined) {
            return;
        }
        self.eventEmitter.emit(EventType.MessageDeleted, Long.fromValue(messageUid));
    }

    onUserReceivedMessage(receivedMapStr) {
        if (!self.isLogined) {
            return;
        }
        let deliveries = JSON.parse(receivedMapStr);
        let deliveryMap = new Map();
        deliveries.forEach(e => {
            deliveryMap.set(e.key, e.value);
        });
        self.eventEmitter.emit(EventType.MessageReceived, deliveryMap);
        console.log('onreceive', deliveryMap);
    }

    onUserReadedMessage(readedMapStr) {
        if (!self.isLogined) {
            return;
        }
        // [{"userId":"GNMtGtZZ","conversationType":1,"target":"Jl8jLjkk","line":0,"readDt":1590308777299} ]
        let arr = JSON.parse(readedMapStr);
        let readEntries = [];
        arr.forEach(e => {
            let entry = new ReadEntry();
            entry.userId = e.userId;
            entry.conversation = new Conversation(e.conversationType, e.target, e.line);
            entry.readTime = e.readDt;
            readEntries.push(entry);
        })
        self.eventEmitter.emit(EventType.MessageRead, readEntries);
        console.log('onread', readEntries)
    }

    onMessageDeleted(messageId) {
        if (!self.isLogined) {
            return;
        }
        self.eventEmitter.emit(EventType.DeleteMessage, messageId);
    }

    onUserInfoUpdate(userIds) {
        if (!self.isLogined) {
            return;
        }
        let userIdArray = JSON.parse(userIds);
        let userInfos = self.getUserInfos(userIdArray)
        userInfos.forEach(ui => {
            self.users.set(ui.uid, ui);
        })
        self.eventEmitter.emit(EventType.UserInfosUpdate, userInfos);
    }

    onFriendListUpdate(friendListIds) {
        if (!self.isLogined) {
            return;
        }
        console.log('friendList update, ids', friendListIds);
        let ids = JSON.parse(friendListIds);
        ids.forEach((uid) => {
            self.users.delete(uid);
        });
        self.eventEmitter.emit(EventType.FriendListUpdate, ids);
    }

    onFriendRequestUpdate(newRequests = '[]') {
        if (!self.isLogined) {
            return;
        }
        console.log('friend request list update, new incomming requests', newRequests);
        let ids = JSON.parse(newRequests);
        self.eventEmitter.emit(EventType.FriendRequestUpdate, ids);
    }

    onSecretChatStateChangedListener(targetId) {
        console.log('onSecretChatStateChangedListener', targetId);
        self.eventEmitter.emit(EventType.SecretChatStateChange, targetId);
    }

    onSecretMessageStartBurningListener(targetId, playedMessageId) {
        console.log('onSecretMessageStartBurningListener', targetId, playedMessageId);
        self.eventEmitter.emit(EventType.SecretChatStartBurn, targetId, playedMessageId);
    }

    onSecretMessageBurnedListener(messageIds) {
        console.log('onSecretMessageBurnedListener', messageIds);
        self.eventEmitter.emit(EventType.SecretChatMessageBurned, messageIds)
    }

    init(args = []) {
        protoProxy.init();
        // if(process.platform === 'win32'){
        //     protoProxy.invoke('setDBPath', process.cwd());
        // }
        // protoProxy.invoke('setAppName', 'mychat');
        protoProxy.invoke('setLanguage', Config.LANGUAGE);

        this._setupEventListeners();

        self.registerDefaultMessageContents();

        window.__uploadingMap = this.uploadingMap;
    }

    attach() {
        this.connectionStatus = protoProxy.invoke('getConnectionStatus');
        if (this.connectionStatus === ConnectionStatus.ConnectionStatusConnected) {
            this.isLogined = true;
            this.userId = protoProxy.invoke('getCurrentUserId');
        }
        protoProxy.init();
        this._setupEventListeners();
    }

    registerMessageContent(name, flag, type, clazz) {
        MessageConfig.MessageContents.push(
            {
                name: name,
                flag: flag,
                type: type,
                contentClazz: clazz,
            }
        );
        protoProxy.invoke("registerMessageFlag", type, flag);
    }

    useSM4() {
        protoProxy.invoke('useSM4');
    }

    useAES256() {
        protoProxy.invoke('useAES256');
    }

    useTcpShortLink() {
        protoProxy.invoke('useTcpShortLink');
    }

    /**
     * 是否启动 TCP 短连接
     * @return {*}
     */
    isTcpShortLink() {
        return protoProxy.invoke('isTcpShortLink');
    }


    connect(userId, token) {
        if (!self.userId) {
            self.userId = userId;
            let status = this.getConnectionStatus();
            if (status === ConnectionStatus.ConnectionStatusConnected) {
                this.onConnectionChanged(status);
                return false;
            }
        }
        self.userId = userId;

        let lastActiveTime = protoProxy.invoke('connect', userId, token);
        console.log('lastActiveTime', lastActiveTime);
        // 超过一周没有活跃，就预加载数据
        if (new Date().getTime() / 1000 - lastActiveTime > 7 * 24 * 60 * 60) {
            self.needPreloadDefaultData = true;
        }
        return lastActiveTime;
        // for testing your code
        // self.test();
    }

    setProxyInfo(host, ip, port, username, password) {
        protoProxy.invoke('setProxyInfo', host, ip, port, username, password);
    }

    setPackageName(packageName) {
        protoProxy.invoke('setPackageName', packageName);
    }

    disconnect() {
        self.userId = '';
        protoProxy.invoke('disconnect', 0);


        //sleep 1 second wait disconnect with im server
        var now = new Date();
        var exitTime = now.getTime() + 1000;
        while (true) {
            now = new Date();
            if (now.getTime() > exitTime)
                return;
        }
    }

    registerDefaultMessageContents() {
        MessageConfig.MessageContents.map((e) => {
            protoProxy.invoke('registerMessageFlag', e.type, e.flag);
        });
    }

    getClientId() {
        return protoProxy.invoke('getClientId');
    }

    getProtoRevision() {
        return protoProxy.invoke('getProtoRevision');
    }

    getUserId() {
        return self.userId;
    }

    getServerDeltaTime() {
        return protoProxy.invoke('getServerDeltaTime');
    }

    isLogin() {
        // return proto.isLogin();
        return self.isLogined;
    }

    getConnectionStatus() {
        return protoProxy.invoke('getConnectionStatus');
    }

    setBackupAddressStrategy(strategy) {
        protoProxy.invoke('setBackupAddressStrategy', strategy);
    }

    setBackupAddress(backupHost, backupPort) {
        protoProxy.invoke('setBackupAddress', backupHost, backupPort);
    }

    setProtoUserAgent(userAgent) {
        if (typeof userAgent !== 'string') {
            console.error('setProtoUserAgent userAgent must be string');
            return;
        }
        protoProxy.invoke('setUserAgent', userAgent);
    }

    addHttpHeader(header, value) {
        if (typeof header !== "string" || typeof value !== "string") {
            console.error('addHttpHeader header, value must be string')
            return;
        }
        protoProxy.invoke('addHttpHeader', header, value);
    }

    onAppResume() {
        protoProxy.invoke('onAppResume');
    }

    onAppSuspend() {
        protoProxy.invoke('onAppSuspend');
    }

    // setLanguage(language) {
    //     proto.setLanguage(language);
    // }

    getMyGroupList() {
        let settings = this.getUserSettings(UserSettingScope.FavoriteGroup);
        let groupInfos = settings.filter(setting => setting.value === '1')
            .map(setting => this.getGroupInfo(setting.key, false));
        return groupInfos;
    }

    /**
     * @param {string} userId
     * @param {boolean} fresh
     */
    getUserInfo(userId, fresh = false, groupId = '') {
        if (!userId || userId === '') {
            return new NullUserInfo('');
        }
        let userInfo;
        if (!fresh && (!groupId || groupId === '')) {
            userInfo = self.users.get(userId);
            if (userInfo) {
                return userInfo;
            }
        }

        // console.log('getuserInfo', userId, fresh, groupId);
        let userInfoStr = protoProxy.invoke('getUserInfo', userId, fresh, groupId);
        if (userInfoStr === '') {
            userInfo = new NullUserInfo(userId);
        } else {
            userInfo = Object.assign(new UserInfo(), JSON.parse(userInfoStr));
        }
        if (!groupId || groupId === '') {
            self.users.set(userInfo.uid, userInfo);
        }
        return userInfo;
    }

    getUserInfos(userIds, groupId = '') {
        let users = [];
        let userInfoStrs = protoProxy.invoke('getUserInfos', userIds, groupId);
        if (userInfoStrs && userInfoStrs !== '') {
            let tmp = JSON.parse(userInfoStrs);
            tmp.forEach((u) => {
                let userInfo = Object.assign(new UserInfo(), u);
                users.push(userInfo)
            });
        }
        return users;
    }

    async getUserInfoEx(userId, refresh, successCB, failCB) {
        protoProxy.invokeAsync('getUserInfoEx', userId, refresh, (userInfoStr) => {
            const userInfo = Object.assign(new UserInfo(), JSON.parse(userInfoStr));

            if (successCB) {
                successCB(userInfo);
            }
        }, (errorCode) => {
            if (errorCode) {
                failCB(errorCode);
            }

        });
    }

    async searchUser(keyword, searchType, page, successCB, failCB) {
        protoProxy.invokeAsync('searchUser', keyword, searchType, page, (result) => {
            let userListStr = JSON.parse(result);
            let userList = [];
            if (userListStr && userListStr.length > 0) {
                userListStr.forEach(u => {
                    userList.push(Object.assign(new UserInfo(), u));
                });
            }
            if (successCB) {
                successCB(keyword, userList);
            }
        }, (errorCode) => {
            if (errorCode) {
                failCB(errorCode);
            }

        });
    }

    searchFriends(keyword) {
        let result = protoProxy.invoke('searchFriends', keyword);
        let userListStr = JSON.parse(result);
        let userList = [];
        if (userListStr && userListStr.length > 0) {
            userListStr.forEach(u => {
                userList.push(Object.assign(new UserInfo(), u));
            });
        }
        return userList;
    }

    searchGroups(keyword) {
        let result = protoProxy.invoke('searchGroups', keyword);
        let groupSearchResultListStr = JSON.parse(result);
        let groupSearchResultList = [];
        if (groupSearchResultListStr && groupSearchResultListStr.length > 0) {
            groupSearchResultListStr.forEach(g => {
                groupSearchResultList.push(GroupSearchResult.fromProtoGroupSearchResult(g));
            });
        }
        return groupSearchResultList;
    }

    getIncommingFriendRequest() {
        let result = protoProxy.invoke('getIncommingFriendRequest');
        let friendRequestListStr = JSON.parse(result);
        let firendRequestList = [];
        if (friendRequestListStr && friendRequestListStr.length > 0) {
            friendRequestListStr.forEach((r) => {
                firendRequestList.push(Object.assign(new FriendRequest(), r));
            });
        }
        return firendRequestList;
    }

    getOutgoingFriendRequest() {
        let result = protoProxy.invoke('getOutgoingFriendRequest');
        let friendRequestListStr = JSON.parse(result);
        let firendRequestList = [];
        if (friendRequestListStr && friendRequestListStr.length > 0) {
            friendRequestListStr.forEach((r) => {
                firendRequestList.push(Object.assign(new FriendRequest(), r));
            });
        }
        return firendRequestList;
    }

    getOneFriendRequest(userId, incoming) {
        let result = protoProxy.invoke('getFriendRequest', userId, incoming);
        return JSON.parse(result);
    }

    loadFriendRequestFromRemote() {
        protoProxy.invoke('loadFriendRequestFromRemote');
    }

    getFavUsers() {
        let result = protoProxy.invoke('getFavUsers');
        return JSON.parse(result);
    }

    isFavUser(userId) {
        return protoProxy.invoke('isFavUser', userId);
    }

    setFavUser(userId, fav, successCB, failCB) {
        protoProxy.invokeAsync('setFavUser', userId, fav, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    loadRemoteMessages(conversation, contentTypes, beforeUid, count, successCB, failCB) {
        if (!contentTypes) {
            contentTypes = [];
        }
        protoProxy.invokeAsync('getRemoteMessages', JSON.stringify(conversation), stringValue(beforeUid), count, (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('loadRemoteMessages', stringValue(beforeUid), msgs.length);
            successCB && successCB(msgs);
        }, (errorCode) => {
            console.log("loadRemoteMessages failure:", errorCode);
            failCB && failCB(errorCode);
        }, contentTypes);
    }

    loadRemoteMessage(messageUid, successCB, failCB) {
        protoProxy.invokeAsync('getRemoteMessage', stringValue(messageUid), (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('loadRemoteMessage', msgs.length);
            if (msgs.length === 1) {
                successCB && successCB(msgs[0]);
            } else {
                failCB && failCB(-1);
            }
        }, (errorCode) => {
            console.log("loadRemoteMessage failure:", errorCode);
            failCB && failCB(errorCode);
        });
    }

    getUnreadFriendRequestCount() {
        return protoProxy.invoke('getUnreadFriendRequestStatus');
    }

    clearUnreadFriendRequestStatus() {
        protoProxy.invoke('clearUnreadFriendRequestStatus');
    }

    async deleteFriend(userId, successCB, failCB) {
        protoProxy.invokeAsync('deleteFriend', userId, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    async handleFriendRequest(userId, accept, extra, successCB, failCB) {
        protoProxy.invokeAsync('handleFriendRequest', userId, accept, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }

        }, extra);
    }

    isBlackListed(userId) {
        return protoProxy.invoke('isBlackListed', userId);
    }

    getBlackList() {
        let result = protoProxy.invoke('getBlackList');
        return JSON.parse(result);
    }

    setBlackList(userId, block, successCB, failCB) {
        protoProxy.invokeAsync('setBlackList', userId, block, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getMyFriendList(fresh = false) {
        let idsStr = protoProxy.invoke('getMyFriendList', fresh);
        if (idsStr !== '') {
            return JSON.parse(idsStr);
        }
        return [];
    }

    getFriendList(fresh = false) {
        let result = protoProxy.invoke('getFriendList', fresh);
        return JSON.parse(result);
    }

    getFriendAlias(userId) {
        return protoProxy.invoke('getFriendAlias', userId);
    }

    async setFriendAlias(userId, alias, successCB, failCB) {
        protoProxy.invokeAsync('setFriendAlias', userId, alias, successCB, failCB);
    }

    async createGroup(groupId, groupType, name, portrait, groupExtra = '', memberIds = [], memberExtra = '', lines = [0], notifyContent, successCB, failCB) {
        groupId = !groupId ? '' : groupId;
        groupExtra = !groupExtra ? '' : groupExtra;
        memberExtra = !memberExtra ? '' : memberExtra;
        let myUid = self.getUserId();

        if (!memberIds.includes(myUid)) {
            memberIds.push(myUid);
        }

        let payload = notifyContent ? notifyContent.encode() : '';
        let notifyContentStr = JSON.stringify(payload);
        //群组类型0，管理员和群主才能加人和退群，修改群信息；2，严格模式，只有群主和管理员才能操作群
        protoProxy.invokeAsync('createGroup', groupId, groupType, name, portrait, groupExtra, memberIds, memberExtra, lines, notifyContentStr,
            (groupId) => {
                if (successCB) {
                    successCB(groupId);
                }
            },
            (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    async setGroupManager(groupId, isSet, memberIds = [], lines = [0], notifyContent, successCB, failCB) {
        let payload = notifyContent ? notifyContent.encode() : '';
        let notifyContentStr = JSON.stringify(payload);
        protoProxy.invokeAsync('setGroupManager', groupId, isSet, memberIds, lines, notifyContentStr, successCB, failCB);
    }

    async muteOrAllowGroupMembers(groupId, isSet, isAllow, memberIds, notifyLines = [0], notifyContent, successCB, failCB) {
        if (isAllow) {
            let payload = notifyContent ? notifyContent.encode() : '';
            let notifyContentStr = JSON.stringify(payload);
            protoProxy.invokeAsync('allowGroupMember', groupId, isSet, memberIds, notifyLines, notifyContentStr, () => {
                successCB && successCB();
            }, (errorCode) => {
                failCB && failCB(errorCode);
            });
        } else {
            let payload = notifyContent ? notifyContent.encode() : '';
            let notifyContentStr = JSON.stringify(payload);
            protoProxy.invokeAsync('muteGroupMember', groupId, isSet, memberIds, notifyLines, notifyContentStr, () => {
                successCB && successCB();
            }, (errorCode) => {
                failCB && failCB(errorCode);
            });
        }
    }

    async setGroupRemark(groupId, remark, successCB, failCB) {
        protoProxy.invokeAsync('setGroupRemark', groupId, remark, () => {
            successCB && successCB();
        }, (errorCode) => {
            failCB && failCB(errorCode);
        });
    }

    getGroupRemark(groupId) {
        return protoProxy.invoke('setGroupRemark', groupId);
    }

    getGroupInfo(groupId, fresh = false) {
        let groupInfo;
        if (!fresh) {
            groupInfo = self.groups.get(groupId);
            if (groupInfo) {
                return groupInfo;
            }
        }

        console.log('get groupInfo', groupId, fresh);
        let groupInfoStr = protoProxy.invoke('getGroupInfo', groupId, fresh);
        if (groupInfoStr === '') {
            return new NullGroupInfo(groupId);
        } else {
            groupInfo = Object.assign(new GroupInfo(), JSON.parse(groupInfoStr));
            self.groups.set(groupId, groupInfo);
            return groupInfo;
        }
    }

    getGroupInfos(groupIds, fresh = false) {
        let groups = [];
        let groupInfoStrs = protoProxy.invoke('getGroupInfos', groupIds, fresh);
        if (groupInfoStrs && groupInfoStrs !== '') {
            let tmp = JSON.parse(groupInfoStrs);
            tmp.forEach((u) => {
                let groupInfo = Object.assign(new GroupInfo(), u);
                groups.push(groupInfo)
            });
        }
        return groups;
    }

    async getGroupInfoEx(groupId, refresh, successCB, failCB) {
        protoProxy.invokeAsync('getGroupInfoEx', groupId, refresh, (groupInfoStr) => {
            groupInfo = Object.assign(new GroupInfo(), JSON.parse(groupInfoStr));

            if (successCB) {
                successCB(groupInfo);
            }
        }, (errorCode) => {
            if (errorCode) {
                failCB(errorCode);
            }

        });
    }

    addGroupMembers(groupId, memberIds, extra, notifyLines, notifyMessageContent, successCB, failCB) {
        if (!notifyMessageContent) {
            notifyMessageContent = new AddGroupMemberNotification(self.getUserId(), memberIds);
        }
        let payload = notifyMessageContent.encode();
        let notifyContentStr = JSON.stringify(payload);
        extra = !extra ? '' : extra;
        protoProxy.invokeAsync('addMembers', memberIds, groupId, extra, notifyLines, notifyContentStr,
            () => {
                if (successCB) {
                    successCB();
                }
            },
            (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    getGroupMemberIds(groupId, fresh = false) {
        let groupMembers = self.getGroupMembers(groupId, fresh);
        var groupMemberIds = [];
        groupMembers.forEach(e => {
            groupMemberIds.push(e.memberId);
        });
        return groupMemberIds;
    }

    getGroupMembers(groupId, fresh = false) {
        let memberIdsStr = protoProxy.invoke('getGroupMembers', groupId, fresh);
        var members = [];
        let arr = JSON.parse(memberIdsStr);
        arr.forEach(e => {
            members.push(Object.assign(new GroupMember(), e));
        });
        return members;
    }

    getGroupMembersByType(groupId, memberType) {
        let memberIdsStr = protoProxy.invoke('getGroupMembersByType', groupId, memberType);
        var members = [];
        let arr = JSON.parse(memberIdsStr);
        arr.forEach(e => {
            members.push(Object.assign(new GroupMember(), e));
        });
        return members;
    }

    getGroupMember(groupId, memberId) {
        let result = protoProxy.invoke('getGroupMember', groupId, memberId);
        return Object.assign(new GroupMember(), JSON.parse(result));
    }

    async getGroupMembersEx(groupId, refresh, successCB, failCB) {
        protoProxy.invokeAsync('getGroupMembersEx', groupId, refresh, (memberIdsStr) => {
            var members = [];
            let arr = JSON.parse(memberIdsStr);
            arr.forEach(e => {
                members.push(Object.assign(new GroupMember(), e));
            });

            if (successCB) {
                successCB(members);
            }
        }, (errorCode) => {
            if (errorCode) {
                failCB(errorCode);
            }

        });
    }

    kickoffGroupMembers(groupId, memberIds, notifyLines, notifyMsg, successCB, failCB) {
        let payload = notifyMsg ? notifyMsg.encode() : '';
        let strCont = JSON.stringify(payload);
        protoProxy.invokeAsync('kickoffMembers', groupId, memberIds, notifyLines, strCont,
            () => {
                if (successCB) {
                    successCB();
                }

            }, (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    async quitGroup(groupId, lines = [0], notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        protoProxy.invokeAsync('quitGroup', groupId, lines, JSON.stringify(payload), () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    async dismissGroup(groupId, lines = [0], notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        protoProxy.invokeAsync('dismissGroup', groupId, lines, JSON.stringify(payload), () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    async modifyGroupInfo(groupId, type, newValue, lines = [0], notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        protoProxy.invokeAsync('modifyGroupInfo', groupId, type, newValue, lines, JSON.stringify(payload),
            () => {
                if (successCB) {
                    successCB();
                }
            }, (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    async modifyGroupAlias(groupId, alias, lines = [0], notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        protoProxy.invokeAsync('modifyGroupAlias', groupId, alias, lines, JSON.stringify(payload), () => {
            successCB();
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    async modifyGroupMemberAlias(groupId, memberId, alias, lines = [0], notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        protoProxy.invokeAsync('modifyGroupMemberAlias', groupId, memberId, alias, lines, JSON.stringify(payload), () => {
            successCB();
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    async modifyGroupMemberExtra(groupId, memberId, extra, lines = [0], notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        protoProxy.invokeAsync('modifyGroupMemberExtra', groupId, memberId, extra, lines, JSON.stringify(payload), () => {
            successCB();
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    transferGroup(groupId, newOwner, lines = [0], notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        protoProxy.invokeAsync('transferGroup', groupId, newOwner, lines, JSON.stringify(payload), () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getFavGroups() {
        let result = protoProxy.invoke('getFavGroups');
        return JSON.parse(result);
    }

    isFavGroup(groupId) {
        return protoProxy.invoke('isFavGroup', groupId);
    }

    async setFavGroup(groupId, fav, successCB, failCB) {
        protoProxy.invokeAsync('setFavGroup', groupId, fav, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    async getMyGroups(successCB, failCB) {
        protoProxy.invokeAsync('getMyGroups', (groupIds) => {
            if (successCB) {
                successCB(groupIds);
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    async getCommonGroups(userId, successCB, failCB) {
        protoProxy.invokeAsync('getCommonGroups', userId, (groupIds) => {
            if (successCB) {
                successCB(groupIds);
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getUserSetting(scope, key) {
        return protoProxy.invoke('getUserSetting', scope, key);
    }

    getUserSettings(scope) {
        let result = protoProxy.invoke('getUserSettings', scope);
        return JSON.parse(result);
    }

    async setUserSetting(scope, key, value, successCB, failCB) {
        protoProxy.invokeAsync('setUserSetting', scope, key, value, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    modifyMyInfo(modifyMyInfoEntries, successCB, failCB) {
        protoProxy.invokeAsync('modifyMyInfo', modifyMyInfoEntries[0].type, modifyMyInfoEntries[0].value, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    isGlobalSlient() {
        return protoProxy.invoke('isGlobalSlient');
    }

    setGlobalSlient(silent, successCB, failCB) {
        protoProxy.invokeAsync('setGlobalSlient', silent, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    isHiddenNotificationDetail() {
        return ipcRenderer.invoke('isHiddenNotificationDetail');
    }

    async setHiddenNotificationDetail(hide, successCB, failCB) {
        protoProxy.invokeAsync('setHiddenNotificationDetail', hide, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    isHiddenGroupMemberName(groupId) {
        return protoProxy.invoke('isHiddenGroupMemberName', groupId);
    }

    async setHiddenGroupMemberName(groupId, hide, successCB, failCB) {
        protoProxy.invokeAsync('setHiddenGroupMemberName', groupId, hide, () => {
            successCB();
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    isUserReceiptEnabled() {
        return protoProxy.invoke('isUserReceiptEnabled');
    }

    async setUserEnableReceipt(enable, successCB, failCB) {
        protoProxy.invokeAsync('setUserReceiptEnable', enable, () => {
            successCB && successCB();
        }, (errorCode) => {
            failCB && failCB(errorCode);
        });
    }

    async joinChatroom(chatroomId, successCB, failCB) {
        protoProxy.invokeAsync('joinChatroom', chatroomId, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    quitChatroom(chatroomId, successCB, failCB) {
        protoProxy.invokeAsync('quitChatroom', chatroomId, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getChatroomInfo(chatroomId, updateDt, successCB, failCB) {
        protoProxy.invokeAsync('getChatroomInfo', chatroomId, '' + updateDt, (info) => {
            if (successCB) {
                successCB(Object.assign(new ChatRoomInfo(), JSON.parse(info)));
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getChatroomMemberInfo(chatroomId, maxCount, successCB, failCB) {
        protoProxy.invokeAsync('getChatroomMemberInfo', chatroomId, maxCount, (info) => {
            if (successCB) {
                successCB(Object.assign(new ChatRoomMemberInfo(), JSON.parse(info)));
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    createChannel(name, portrait, desc, extra, successCB, failCB) {
        protoProxy.invokeAsync('createChannel', name, portrait, 0, desc, extra, (info) => {
            if (successCB) {
                successCB(Object.assign(new ChannelInfo(), JSON.parse(info)));
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getChannelInfo(channelId, refresh = false) {
        let result = protoProxy.invoke('getChannelInfo', channelId, refresh);
        if (result === '') {
            return new NullChannelInfo(channelId);
        }

        let ci = Object.assign(new ChannelInfo(), JSON.parse(result));
        if (ci.menus) {
            ci.menus = ci.menus.map(menu => {
                menu = Object.assign(new ChannelMenu(), menu)
                if (menu.subMenus) {
                    menu.subMenus = menu.subMenus.map(sm => Object.assign(new ChannelMenu(), sm))
                }
                return menu;
            })
        }
        return ci;
    }

    async modifyChannelInfo(channelId, type, newValue, successCB, failCB) {
        protoProxy.invokeAsync('modifyChannelInfo', channelId, type, newValue, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    searchChannel(keyword, successCB, failCB) {
        protoProxy.invokeAsync('searchChannel', keyword, (result) => {
            if (successCB) {
                let channels = [];
                let tmp = JSON.parse(result);
                tmp.forEach(channel => {
                    channels.push(Object.assign(new ChannelInfo(), channel));
                });
                successCB(keyword, channels);
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    isListenedChannel(channelId) {
        return protoProxy.invoke('isListenedChannel', channelId);
    }

    async listenChannel(channelId, listen, successCB, failCB) {
        protoProxy.invokeAsync('listenChannel', channelId, listen, () => {
            successCB && successCB();
        }, errorCode => {
            failCB && failCB(errorCode);
        });
    }

    // return channelIds
    getMyChannels() {
        let result = protoProxy.invoke('getMyChannels');
        return JSON.parse(result);
    }

    getListenedChannels() {
        let result = protoProxy.invoke('getListenedChannels');
        return JSON.parse(result);
    }

    getRemoteListenedChannels(successCB, failCB) {
        protoProxy.invokeAsync('getRemoteListenedChannels', (channelIds) => {
            successCB && successCB(channelIds);
        }, errorCode => {
            failCB && failCB(errorCode);
        });
    }

    async destoryChannel(channelId, successCB, failCB) {
        protoProxy.invokeAsync('destoryChannel', channelId, () => {
            if (successCB) {
                successCB();
            }
        }, errorCode => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getConversationList(types, lines) {
        let conversationListStr = protoProxy.invoke('getConversationInfos', types, lines);
        // console.log(conversationListStr);
        // TODO convert to conversationInfo, messageContent

        let conversationInfoList = [];
        let tmp = JSON.parse(conversationListStr);
        tmp.forEach(c => {
            conversationInfoList.push(ConversationInfo.protoConversationToConversationInfo(c));
        });

        return conversationInfoList;
    }

    getConversationInfo(conversation) {
        let convStr = protoProxy.invoke('getConversationInfo', JSON.stringify(conversation));
        return ConversationInfo.protoConversationToConversationInfo(JSON.parse(convStr));
    }

    searchConversation(keyword, types = [], lines = []) {
        let result = protoProxy.invoke('searchConversation', keyword, types, lines);
        let resultList = JSON.parse(result);
        var conversationSearchResult = [];
        if (resultList && resultList.length > 0) {
            resultList.forEach(r => {
                conversationSearchResult.push(ConversationSearchResult.fromProtoConversationSearchResult(r));
            });
        }
        return conversationSearchResult;
    }

    searchConversationEx(keyword, types, lines, startTime, endTime, desc, limit, offset) {
        let result = protoProxy.invoke('searchConversationEx', keyword, types, lines, startTime, endTime, desc, limit, offset);
        let resultList = JSON.parse(result);
        var conversationSearchResult = [];
        if (resultList && resultList.length > 0) {
            resultList.forEach(r => {
                conversationSearchResult.push(ConversationSearchResult.fromProtoConversationSearchResult(r));
            });
        }
        return conversationSearchResult;
    }

    searchConversationEx2(keyword, types, lines, cntTypes, startTime, endTime, desc, limit, offset, onlyMentionedMsg) {
        let result = protoProxy.invoke('searchConversationEx2', keyword, types, lines, cntTypes, startTime, endTime, desc, limit, offset, onlyMentionedMsg);
        let resultList = JSON.parse(result);
        var conversationSearchResult = [];
        if (resultList && resultList.length > 0) {
            resultList.forEach(r => {
                conversationSearchResult.push(ConversationSearchResult.fromProtoConversationSearchResult(r));
            });
        }
        return conversationSearchResult;
    }

    async removeConversation(conversation, clearMsg) {
        protoProxy.invoke('removeConversation', JSON.stringify(conversation), clearMsg);
    }

    setConversationTop(conversation, top, successCB, failCB) {
        protoProxy.invokeAsync('setConversationTop', JSON.stringify(conversation), top, () => {
            let conversationInfo = self.getConversationInfo(conversation);
            self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);

            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    setConversationSlient(conversation, silent, successCB, failCB) {
        protoProxy.invokeAsync('setConversationSlient', JSON.stringify(conversation), silent, () => {
            let conversationInfo = self.getConversationInfo(conversation);
            self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);

            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    setConversationDraft(conversation, draft = '') {
        let conversationInfo = self.getConversationInfo(conversation);
        if (conversationInfo.draft === draft) {
            return;
        }
        protoProxy.invoke('setConversationDraft', JSON.stringify(conversation), draft);
        conversationInfo = self.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    //timestamp 为毫秒，字符串类型
    setConversationTimestamp(conversation, timestamp) {
        timestamp = timestamp + '';
        protoProxy.invoke('setConversationTimestamp', JSON.stringify(conversation), timestamp);
        let conversationInfo = self.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    getUnreadCount(types = [], lines = [0]) {
        let unreadCountStr = protoProxy.invoke('getUnreadCount', types, lines);
        return Object.assign(new UnreadCount(), JSON.parse(unreadCountStr));
    }

    getConversationUnreadCount(conversation) {
        let unreadCountStr = protoProxy.invoke('getConversationUnreadCount', JSON.stringify(conversation));
        return Object.assign(new UnreadCount(), JSON.parse(unreadCountStr));
    }

    clearConversationUnreadStatus(conversation) {
        protoProxy.invoke('clearUnreadStatus', JSON.stringify(conversation));
        let conversationInfo = self.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    clearUnreadStatusBeforeMessage(conversation, messageId) {
        protoProxy.invoke('clearMessageUnreadStatusBefore', JSON.stringify(conversation), messageId);
        let conversationInfo = self.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    clearUnreadStatusBeforeMessage(conversation, messageId) {
        protoProxy.invoke('clearMessageUnreadStatusBefore', JSON.stringify(conversation), messageId);
        let conversationInfo = self.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    markConversationAsUnread(conversation, syncToOtherClient) {
        let msgUid = protoProxy.invoke('setLastReceivedMessageUnRead', JSON.stringify(conversation), '0', '0');
        if (msgUid && gt(msgUid, 0)) {
            if (syncToOtherClient) {
                let msg = this.getMessageByUid(msgUid);
                let content = new MarkUnreadMessageContent(msgUid);
                content.timestamp = msg.timestamp;
                this.sendConversationMessage(conversation, content)
            }
            let conversationInfo = self.getConversationInfo(conversation);
            self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
            return true;
        }
        return false;
    }

    getConversationRead(conversation) {
        let readedStr = protoProxy.invoke('getConversationRead', JSON.stringify(conversation));
        let readedArr = JSON.parse(readedStr);
        let result = new Map();
        if (readedArr) {
            readedArr.forEach(e => {
                result.set(e.key, e.value)
            })
        }
        return result;
    }

    getConversationDelivery(conversation) {
        let deliveryStr = protoProxy.invoke('getMessageDelivery', JSON.stringify(conversation));
        let deliveryArr = JSON.parse(deliveryStr);
        let result = new Map();
        if (deliveryArr) {
            deliveryArr.forEach(e => {
                result.set(e.key, e.value)
            })
        }
        return result;
    }

    clearMessageUnreadStatus(messageId) {
        protoProxy.invoke('clearMessageUnreadStatus', messageId);
    }

    clearAllUnreadStatus() {
        // TODO emit ConversationInfoUpdate event
        protoProxy.invoke('clearAllUnreadStatus');
    }

    getConversationFirstUnreadMessageId(conversation) {
        let messageId = protoProxy.invoke('getConversationFirstUnreadMessageId', JSON.stringify(conversation));
        return messageId;
    }

    setMediaMessagePlayed(messageId) {
        // TODO need to emit message update event?
        protoProxy.invoke('setMediaMessagePlayed', messageId);
    }

    setMessageLocalExtra(messageId, extra) {
        protoProxy.invoke('setMessageLocalExtra', messageId, extra);
    }

    isMyFriend(userId) {
        return protoProxy.invoke('isMyFriend', userId);
    }

    async sendFriendRequest(userId, reason, extra, successCB, failCB) {
        extra = !extra ? '' : extra;
        protoProxy.invokeAsync('sendFriendRequest', userId, reason, extra, () => {
            if (successCB) {
                successCB();
            }

        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    /**
     *
     * @param {Conversation} conversation
     * @param {number} fromIndex
     * @param {boolean} before
     * @param {number} count
     * @param {string} withUser
     * @param {array} contentTypes
     */
    getMessages(conversation, fromIndex, before = true, count = 20, withUser = '') {
        let protoMsgsStr = protoProxy.invoke('getMessages', JSON.stringify(conversation), [], fromIndex, before, count, withUser);
        // let protoMsgsStr = proto.getMessages('xxx', [0], fromIndex, before, count, withUser);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessages', msgs.length);

        return msgs;
    }

    getMessagesV2(conversation, fromIndex, before, count, withUser, successCB, failCB) {
        protoProxy.invokeAsync('getMessagesV2', JSON.stringify(conversation), [], fromIndex, before, count, withUser, (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('getMessagesV2', msgs.length);
            successCB && successCB(msgs);
        }, (errorCode) => {
            console.log("getMessagesV2 failure:", errorCode);
            failCB && failCB(errorCode);
        });
    }

    getMentionedMessages(conversation, fromIndex, before, count, successCB, failCB) {
        protoProxy.invokeAsync('getMentionedMessages', JSON.stringify(conversation), fromIndex, before, count, (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('getMentionedMessages', msgs.length);
            successCB && successCB(msgs);
        }, (errorCode) => {
            console.log("getMentionedMessages failure:", errorCode);
            failCB && failCB(errorCode);
        });
    }

    getMessagesEx(conversationTypes, lines, contentTypes, fromIndex, before = true, count = 20, withUser = '') {
        let protoMsgsStr = protoProxy.invoke('getMessagesEx', conversationTypes, lines, contentTypes, fromIndex, before, count, withUser);
        // let protoMsgsStr = proto.getMessages('xxx', [0], fromIndex, before, count, withUser);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessages', msgs.length);

        return msgs;
    }

    getMessagesExV2(conversationTypes, lines, contentTypes, fromIndex, before, count, withUser, successCB, failCB) {
        protoProxy.invokeAsync('getMessagesExV2', conversationTypes, lines, contentTypes, fromIndex, before, count, withUser, (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('getMessagesExV2', msgs.length);
            successCB && successCB(msgs);
        }, (errorCode) => {
            console.log("getMessagesExV2 failure:", errorCode);
            failCB && failCB(errorCode);
        });
    }

    getMessagesEx2(conversationTypes, lines, status, fromIndex, before = true, count = 20, withUser = '') {
        let protoMsgsStr = protoProxy.invoke('getMessagesEx2', conversationTypes, lines, status, fromIndex, before, count, withUser);
        // let protoMsgsStr = proto.getMessages('xxx', [0], fromIndex, before, count, withUser);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessages', msgs.length);

        return msgs;
    }

    getMessagesEx2V2(conversationTypes, lines, status, fromIndex, before, count, withUser, successCB, failCB) {
        protoProxy.invokeAsync('getMessagesEx2V2', conversationTypes, lines, status, fromIndex, before, count, withUser, (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('getMessagesEx2V2', msgs.length);
            successCB && successCB(msgs);
        }, (errorCode) => {
            console.log("getMessagesEx2V2 failure:", errorCode);
            failCB && failCB(errorCode);
        });
    }

    getMessagesByTimestamp(conversation, contentTypes, timestamp, before = true, count = 20, withUser = '') {
        let protoMsgsStr = protoProxy.invoke('getMessagesByTimestamp', JSON.stringify(conversation), contentTypes, timestamp, before, count, withUser);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessagesByTimestamp', msgs.length);

        return msgs;
    }

    getMessagesByTimestampV2(conversation, contentTypes, timestamp, before, count, withUser, successCB, failCB) {
        protoProxy.invokeAsync('getMessagesByTimestampV2', JSON.stringify(conversation), contentTypes, timestamp, before, count, withUser, (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('getMessagesByTimestampV2', msgs.length);
            successCB && successCB(msgs);
        }, (errorCode) => {
            console.log("getMessagesByTimestampV2 failure:", errorCode);
            failCB && failCB(errorCode);
        });
    }

    getMessagesByStatusV2(conversation, statuses, fromIndex, before, count, withUser, successCB, failCB) {
        protoProxy.invokeAsync('getMessagesByStatusV2', JSON.stringify(conversation), statuses, fromIndex, before, count, withUser, (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('getMessagesByStatusV2', msgs.length);
            successCB && successCB(msgs);
        }, (errorCode) => {
            console.log("getMessagesByStatusV2 failure:", errorCode);
            failCB && failCB(errorCode);
        });
    }

    getUserMessages(userId, conversation, fromIndex, before = true, count = 20, contentTypes = []) {
        let protoMsgsStr = protoProxy.invoke('getUserMessages', userId, JSON.stringify(conversation), contentTypes, fromIndex, before, count);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessages', msgs.length);

        return msgs;
    }

    getUserMessagesV2(userId, conversation, fromIndex, before, count, contentTypes, successCB, failCB) {
        protoProxy.invokeAsync('getUserMessagesV2', userId, JSON.stringify(conversation), contentTypes, fromIndex, before, count, (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('getUserMessagesV2', msgs.length);
            successCB && successCB(msgs);
        }, (errorCode) => {
            console.log("getUserMessagesV2 failure:", errorCode);
            failCB && failCB(errorCode);
        });
    }

    getUserMessagesEx(userId, conversationTypes, lines, fromIndex, before = true, count = 20, contentTypes = []) {
        let protoMsgsStr = protoProxy.invoke('getUserMessagesEx', userId, conversationTypes, lines, contentTypes, fromIndex, before, count);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessages', msgs.length);

        return msgs;
    }

    getUserMessagesExV2(userId, conversationTypes, lines, fromIndex, before, count, contentTypes, successCB, failCB) {
        protoProxy.invokeAsync('getUserMessagesExV2', userId, conversationTypes, lines, contentTypes, fromIndex, before, count, (protoMsgsStr) => {
            let protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('getUserMessagesExV2', msgs.length);
            successCB && successCB(msgs);
        }, (errorCode) => {
            console.log("getUserMessagesExV2 failure:", errorCode);
            failCB && failCB(errorCode);
        });
    }

    getMessageById(messageId) {
        let mStr = protoProxy.invoke('getMessage', messageId);
        return Message.fromProtoMessage(JSON.parse(mStr));
    }

    getMessageByUid(messageUid) {
        let mStr = protoProxy.invoke('getMessageByUid', Long.fromValue(messageUid).toString());
        return Message.fromProtoMessage(JSON.parse(mStr));
    }

    searchMessage(conversation, keyword, withUser = '') {
        let result = protoProxy.invoke('searchMessage', JSON.stringify(conversation), keyword, withUser);
        let msgs = JSON.parse(result);
        let matchMsgs = [];
        if (msgs && msgs.length > 0) {
            msgs.forEach(m => {
                matchMsgs.push(Message.fromProtoMessage(m));
            });
        }

        return matchMsgs;
    }

    searchMessageEx(conversation, keyword, desc, limit, offset, withUser = '') {
        let result = protoProxy.invoke('searchMessageEx', JSON.stringify(conversation), keyword, desc, limit, offset, withUser);
        let msgs = JSON.parse(result);
        let matchMsgs = [];
        if (msgs && msgs.length > 0) {
            msgs.forEach(m => {
                matchMsgs.push(Message.fromProtoMessage(m));
            });
        }

        return matchMsgs;
    }

    searchMentionedMessages(conversation, keyword, desc, limit, offset) {
        let result = protoProxy.invoke('searchMentionedMessages', JSON.stringify(conversation), keyword, desc, limit, offset);
        let msgs = JSON.parse(result);
        let matchMsgs = [];
        if (msgs && msgs.length > 0) {
            msgs.forEach(m => {
                matchMsgs.push(Message.fromProtoMessage(m));
            });
        }

        return matchMsgs;
    }

    searchMessageByTypes(conversation, keyword, contentTypes, desc, limit, offset, withUser = '') {
        if (!contentTypes) {
            contentTypes = [];
        }
        let result = protoProxy.invoke('searchMessageByTypes', JSON.stringify(conversation), keyword, contentTypes, desc, limit, offset, withUser);
        let msgs = JSON.parse(result);
        let matchMsgs = [];
        if (msgs && msgs.length > 0) {
            msgs.forEach(m => {
                matchMsgs.push(Message.fromProtoMessage(m));
            });
        }

        return matchMsgs;
    }

    searchMessageByTypesAndTimes(conversation, keyword, contentTypes, startTime, endTime, desc, limit, offset, withUser = '') {
        if (!contentTypes) {
            contentTypes = [];
        }
        let result = protoProxy.invoke('searchMessageByTypesAndTimes', JSON.stringify(conversation), keyword, contentTypes, startTime.toString(), endTime.toString(), desc, limit, offset, withUser);
        let msgs = JSON.parse(result);
        let matchMsgs = [];
        if (msgs && msgs.length > 0) {
            msgs.forEach(m => {
                matchMsgs.push(Message.fromProtoMessage(m));
            });
        }

        return matchMsgs;
    }

    searchMessageEx2(conversationTypes, lines, contentTypes, keyword, fromIndex, desc, count, withUser = '') {
        if (!contentTypes) {
            contentTypes = [];
        }
        let result = protoProxy.invoke('searchMessageEx2', conversationTypes, lines, contentTypes, keyword, fromIndex, desc, count, withUser);
        let msgs = JSON.parse(result);
        let matchMsgs = [];
        if (msgs && msgs.length > 0) {
            msgs.forEach(m => {
                matchMsgs.push(Message.fromProtoMessage(m));
            });
        }

        return matchMsgs;
    }

    searchMentionedMessageEx(conversationTypes, lines, keyword, desc, limit, offset) {
        if (!conversationTypes) {
            conversationTypes = [];
        }
        let result = protoProxy.invoke('searchMentionedMessagesEx', conversationTypes, lines, keyword, desc, limit, offset);
        let msgs = JSON.parse(result);
        let matchMsgs = [];
        if (msgs && msgs.length > 0) {
            msgs.forEach(m => {
                matchMsgs.push(Message.fromProtoMessage(m));
            });
        }

        return matchMsgs;
    }

    async sendConversationMessage(conversation, messageContent, toUsers = [], preparedCB, progressCB, successCB, failCB) {
        let message = new Message();
        message.conversation = conversation;
        message.messageContent = messageContent;
        self.sendMessageEx(message, toUsers, preparedCB, progressCB, successCB, failCB);
    }

    async sendMessage(message, preparedCB, progressCB, successCB, failCB) {
        self.sendMessageEx(message, [], preparedCB, progressCB, successCB, failCB);
    }

    // toUsers 用来实现定向消息
    async sendMessageEx(message, toUsers = [], preparedCB, progressCB, successCB, failCB) {
        let strConv = JSON.stringify(message.conversation);
        message.content = message.messageContent.encode();
        message.from = this.userId;

        let mediaMessageUploadCallback;
        if (message.messageContent instanceof TextMessageContent && Config.SEND_LOG_COMMAND && Config.SEND_LOG_COMMAND.trim() && message.messageContent.content === Config.SEND_LOG_COMMAND.trim()) {
            let latestLogFilePath = this._getLatestLogFilePath();
            if (latestLogFilePath) {
                mediaMessageUploadCallback = (remoteUrl) => {
                    let textMessageContent = new TextMessageContent(remoteUrl);
                    this.sendConversationMessage(message.conversation, textMessageContent);
                }
                let file = {
                    path: latestLogFilePath,
                    name: latestLogFilePath.substring((latestLogFilePath.lastIndexOf('/') + 1)),
                    size: require('fs').statSync(latestLogFilePath).size

                }
                let mediaMessageContent = new FileMessageContent(file, null)
                message.messageContent = mediaMessageContent;
                message.content = mediaMessageContent.encode();
            }
        }
        if (message.messageContent instanceof MediaMessageContent
            && (message.messageContent.localPath || message.messageContent.file)
            && !message.messageContent.remotePath
            && this.isTcpShortLink() && !this.isSupportBigFilesUpload()) {
            console.error('TCP短连接不支持内置对象存储，请把对象存储切换到其他类型')
            failCB && failCB(-1);
            return;
        }

        if (message.messageContent instanceof MediaMessageContent && (message.messageContent.localPath || message.messageContent.file) && !message.messageContent.remotePath && this.isSupportBigFilesUpload()) {
            let insertedMsg = this.insertMessage(message.conversation, message.messageContent, MessageStatus.Sending, false, toUsers, 0);
            // 有一个副作用，后续调用sendSavedMessage时，还会触发一次 SendMessage 事件
            this.eventEmitter.emit(EventType.SendMessage, insertedMsg);
            preparedCB && preparedCB(insertedMsg.messageId, insertedMsg.timestamp);

            // 截图、粘贴发送等
            let file;
            if (message.messageContent.localPath && (!message.messageContent.file || !(message.messageContent.file instanceof File))) {
                let path = message.messageContent.file ? message.messageContent.file.path : message.messageContent.localPath;
                let name = message.messageContent.file ? message.messageContent.file.name : message.messageContent.name;
                file = await this.readLocalFile(path, name)
            } else {
                file = message.messageContent.file;
            }
            if ((process.platform === 'darwin' || process.platform === "win32") && message.messageContent instanceof ImageMessageContent) {
                // 粘贴发送图片
                if (message.messageContent.localPath) {
                    let thumbnail = await require('electron').nativeImage.createThumbnailFromPath(message.messageContent.localPath, {width: 200, height: 200})
                    let dataUrl = thumbnail.toDataURL();
                    message.messageContent.thumbnail = dataUrl.substring('data:image/png;base64,'.length)
                } else {
                    // 选取图片发送
                    // TODO
                }
            }

            // image/jpeg
            this._uploadFile(insertedMsg, file, message.messageContent.mediaType, (uploaded, total) => {
                progressCB && progressCB(uploaded, total, insertedMsg.messageId);
            }, (remoteUrl) => {
                insertedMsg.messageContent.remotePath = remoteUrl;
                this.updateMessageContent(insertedMsg.messageId, insertedMsg.messageContent);
                protoProxy.invokeAsync('sendSavedMessage', insertedMsg.messageId, 0, (messageUid, timestamp) => {
                    messageUid = Long.fromValue(messageUid);
                    insertedMsg.messageUid = messageUid;
                    insertedMsg.timestamp = timestamp;
                    insertedMsg.status = MessageStatus.Sent;
                    console.log('send saved msg success', messageUid, insertedMsg);
                    successCB && successCB(insertedMsg.messageUid, insertedMsg.timestamp);
                }, err => {
                    failCB && failCB(err)
                })
                mediaMessageUploadCallback && mediaMessageUploadCallback(remoteUrl);
            }, (err) => {
                this.updateMessageStatus(insertedMsg.messageId, MessageStatus.SendFailure);
                insertedMsg.status = MessageStatus.SendFailure;
                failCB && failCB(err);
            });
            return
        }

        if (message.messageContent instanceof MediaMessageContent) {
            if (!message.messageContent.localPath && message.messageContent.file) {
                let file = message.messageContent.file;
                let filePath = path.join(os.tmpdir(), file.name);
                let buffer = Buffer.from(await file.arrayBuffer())
                require('fs').writeFileSync(filePath, buffer);
                message.messageContent.localPath = filePath;

                message.content = message.messageContent.encode();
            }
        }

        let strCont = JSON.stringify(message.content);
        let msgStr = protoProxy.sendMessage(strConv, strCont, toUsers, 0,
            (messageId, timestamp) => { //preparedCB
                message.messageId = messageId;
                message.timestamp = Long.fromValue(timestamp).toNumber();
            },
            (uploaded, total) => { //progressCB
                if (typeof progressCB === 'function') {
                    progressCB(uploaded, total, message.messageId);
                }
                // upload progress update
            },
            (messageUid, timestamp) => { //successCB
                message.status = MessageStatus.Sent;
                message.messageUid = Long.fromValue(messageUid);
                message.timestamp = Long.fromValue(timestamp).toNumber();
                // update remote url
                if (message.messageContent instanceof MediaMessageContent) {
                    let msg = self.getMessageById(message.messageId);
                    message.messageContent = msg.messageContent;
                }
                if (message.conversation.type === ConversationType.ChatRoom) {
                    this.eventEmitter.emit(EventType.MessageStatusUpdate, message);
                }

                if (typeof successCB === 'function') {
                    successCB(Long.fromValue(messageUid), Long.fromValue(timestamp).toNumber());
                }
            },
            (errorCode) => { //errorCB
                message.status = MessageStatus.SendFailure;
                if (message.conversation.type === ConversationType.ChatRoom) {
                    this.eventEmitter.emit(EventType.MessageStatusUpdate, message);
                }
                if (typeof failCB === 'function') {
                    failCB(errorCode);
                }
            });


        let msgObj = JSON.parse(msgStr);
        message.messageId = msgObj.messageId;
        message.timestamp = Long.fromValue(msgObj.timestamp).toNumber();
        if (typeof preparedCB === 'function') {
            preparedCB(message.messageId, Long.fromValue(msgObj.timestamp).toNumber());
        }
    }

    async sendSavedMessage(message, expireDuration, successCB, failCB) {
        protoProxy.invokeAsync('sendSavedMessage', message.messageId, expireDuration,
            (messageUid, timestamp) => { //successCB
                message.status = MessageStatus.Sent;
                message.messageUid = Long.fromValue(messageUid);
                message.timestamp = Long.fromValue(timestamp).toNumber();
                // update remote url
                if (message.messageContent instanceof MediaMessageContent) {
                    let msg = self.getMessageById(message.messageId);
                    message.messageContent = msg.messageContent;
                }

                if (typeof successCB === 'function') {
                    successCB(Long.fromValue(messageUid), Long.fromValue(timestamp).toNumber());
                }
            },
            (errorCode) => { //errorCB
                message.status = MessageStatus.SendFailure;
                if (typeof failCB === 'function') {
                    failCB(errorCode);
                }
            });
    }

    async readLocalFile(path, name) {
        let response = await fetch('file://' + path);
        let data = await response.blob();
        return new File([data], name);
    }

    cancelSendingMessage(messageId) {
        let canceled = protoProxy.invoke('cancelSendingMessage', messageId);
        if (!canceled) {
            let xhr = this.uploadingMap.get(messageId);
            if (xhr) {
                this.uploadingMap.delete(messageId);
                try {
                    xhr.abort();
                    canceled = true;
                } catch (e) {
                    console.log(e);
                }
            }
        }
        return canceled;
    }

    // cancelUploadBigFile(remoteUrl) {
    //     miscState.uploadBigFiles.forEach(upload => {
    //         if (upload.remoteUrl === remoteUrl) {
    //             let xhr = upload.xhr;
    //             upload.status = 3;
    //             upload.xhr = null;
    //             xhr && xhr.abort();
    //         }
    //     })
    // }

    _uploadXMLHttpRequest(messageId, fileName, remoteUrl, progressCB, successCB, failCB) {
        let xhr = new XMLHttpRequest();
        xhr.upload.onprogress = (e) => {
            // console.log('upload.onprogress', Math.ceil(e.loaded / e.total * 100))
            let progress = e.loaded;
            let total = e.total;
            progressCB(progress, total);
        }
        xhr.onreadystatechange = (e) => {
            console.log('onr', xhr.readyState, xhr.status, e)
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    console.log('upload file success', fileName, remoteUrl);
                    this.uploadingMap.delete(messageId);
                    successCB(remoteUrl);
                } else {
                    console.log('upload file error', xhr.status);
                    this.uploadingMap.delete(messageId);
                    failCB && failCB(-1);
                }
            }
        }
        xhr.onerror = e => {
            console.log('upload file error', e);
            this.uploadingMap.delete(messageId);
            failCB && failCB(-1);
        }

        if (messageId) {
            this.uploadingMap.set(messageId, xhr);
        }
        return xhr;
    }

    // 大文件上传
    async _uploadFile(message, file, mediaType, progressCB, successCB, failCB) {

        let fileName = encodeURIComponent(file.name);
        if (message && message.conversation.type === ConversationType.SecretChat) {
            let arrayBuffer = await file.arrayBuffer();
            let encodedAb = protoProxy.invoke('encodeSecretChatMediaData', message.conversation.target, arrayBuffer);
            file = new Blob([new Uint8Array(encodedAb, 0, encodedAb.byteLength)]);
        }

        let contentType = this._getContentType(mediaType, fileName);
        this.getUploadMediaUrl(fileName, mediaType, contentType, (uploadUrl, remoteUrl, backUploadUrl, serverType) => {
            console.log('getUploadMediaUrl', uploadUrl, remoteUrl, backUploadUrl, serverType)
            let xhr;
            if (serverType === 0) {
                // 内置存储，不支持大文件上传
            } else if (serverType === 1) {
                // qiniu
                let ss = uploadUrl.split('?');
                let url = ss[0];
                let token = ss[1];
                let key = ss[2];
                xhr = this._uploadXMLHttpRequest(message ? message.messageId : 0, fileName, remoteUrl, progressCB, successCB, failCB);

                let formData = new FormData();
                formData.append('key', key)
                formData.append('token', token)
                formData.append('file', file)
                xhr.open('POST', url);
                xhr.setRequestHeader('content-type', contentType);
                xhr.setRequestHeader("content-disposition", `attachment; filename="${fileName}"`);
                xhr.send(formData);
            } else {
                // 野火专业存储或阿里云
                xhr = this._uploadXMLHttpRequest(message ? message.messageId : 0, fileName, remoteUrl, progressCB, successCB, failCB);
                xhr.open('PUT', uploadUrl);

                xhr.setRequestHeader('content-type', contentType);
                xhr.setRequestHeader("content-disposition", `attachment; filename="${fileName}"`);
                xhr.send(file);
            }

        }, (e) => {
            console.log('getUploadMediaUrl e', e)
        })
    }

    // 更新了原始消息的内容
    async recallMessage(messageUid, successCB, failCB) {
        console.log('recall', messageUid);
        protoProxy.invokeAsync('recall', messageUid.toString(),
            () => {
                console.log('recall, s', messageUid);
                if (successCB) {
                    successCB();
                }
                this.onRecallMessage(this.getUserId(), messageUid);
            },
            (errorCode) => {
                console.log('recall, f', messageUid, errorCode);
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    async deleteRemoteMessage(messageUid, successCB, failCB) {
        console.log('deleteRemoteMessageByUid', messageUid);
        protoProxy.invokeAsync('deleteRemoteMessage', messageUid.toString(),
            () => {
                if (successCB) {
                    successCB();
                }
                this.onDeleteRemoteMessage(messageUid);
            },
            (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    async updateRemoteMessageContent(messageUid, messageContent, distribute, updateLocal, successCB, failCB) {
        console.log('updateRemoteMessageContent', messageUid);
        let protoMessageContent = messageContent.encode();
        protoProxy.invokeAsync('updateRemoteMessageContent', messageUid.toString(), JSON.stringify(protoMessageContent), distribute, updateLocal,
            () => {
                if (successCB) {
                    successCB();
                }
            },
            (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    deleteMessageById(messageId) {
        let result = protoProxy.invoke('deleteMessage', messageId);
        if (result) {
            this.onMessageDeleted(messageId);
        }
        return result;
    }

    batchDeleteMessages(messageUids) {
        let result = protoProxy.invoke('batchDeleteMessages', messageUids);
        return result;
    }

    watchOnlineState(conversationType, targets, duration, successCB, failCB) {
        protoProxy.invokeAsync('watchOnlineState', conversationType, targets, duration,
            (strStates) => {
                let userOnlineStates = self._parseUserOnlineState(strStates);
                successCB && successCB(userOnlineStates);
            },
            (errorCode) => {
                failCB && failCB(errorCode);
            });
    }

    unwatchOnlineState(conversationType, targets, successCB, failCB) {
        protoProxy.invokeAsync('unwatchOnlineState', conversationType, targets,
            () => {
                if (successCB) {
                    successCB();
                }
            },
            (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    setMyCustomState(customState, customText, successCB, failCB) {
        let csSetting = customState + '-' + customText;
        this.setUserSetting(UserSettingScope.CustomState, "", csSetting, successCB, failCB);
    }

    isCommercialServer() {
        return protoProxy.invoke('isCommercialServer');
    }

    isReceiptEnabled() {
        return protoProxy.invoke('isReceiptEnabled');
    }

    isGlobalDisableSyncDraft() {
        return protoProxy.invoke('isGlobalDisableSyncDraft');
    }

    isUserOnlineStateEnabled() {
        return protoProxy.invoke('isEnableUserOnlineState');
    }

    setDisableSyncDraft(disable, successCB, failCB) {
        this.setUserSetting(UserSettingScope.DisableSyncDraft, '', disable ? '1' : '0',
            () => successCB && successCB(),
            (err) => failCB && failCB(err));
    }

    isDisableSyncDraft() {
        return this.getUserSetting(UserSettingScope.DisableSyncDraft, '') === '1';
    }

    getAuthorizedMediaUrl(messageUid, mediaType, mediaPath, successCB, failCB) {
        protoProxy.invokeAsync('getAuthorizedMediaUrl', stringValue(messageUid), mediaType, mediaPath, successCB, failCB);
    }

    isSupportBigFilesUpload() {
        return protoProxy.invoke('isSupportBigFilesUpload');
    }

    getUploadMediaUrl(fileName, mediaType, contentType, successCB, failCB) {
        protoProxy.invokeAsync('getUploadMediaUrl', fileName, mediaType, contentType, successCB, failCB);
    }

    getConversationFileRecords(conversation, fromUser, beforeUid, order, count, successCB, failCB) {
        protoProxy.invokeAsync('getConversationFiles', JSON.stringify(conversation), fromUser, Long.fromValue(beforeUid).toString(), order, count, (frsStr) => {
            let frs = JSON.parse(frsStr);
            let fileRecords = [];
            frs.forEach(fr => {
                fileRecords.push(this._objStrToFileRecordObj(fr));
            })
            successCB && successCB(fileRecords);
        }, (errorCode) => {
            failCB && failCB(errorCode);
        });
    }

    _objStrToFileRecordObj(obj) {

        let fileRecord = new FileRecord();
        fileRecord.userId = obj.userId;
        fileRecord.conversation = new Conversation(obj.conversationType, obj.target, obj.line);
        fileRecord.messageUid = Long.fromValue(obj.messageUid);
        fileRecord.name = obj.name;
        fileRecord.url = obj.url;
        fileRecord.size = obj.size;
        fileRecord.downloadCount = obj.downloadCount;
        fileRecord.timestamp = obj.timestamp;

        return fileRecord;
    }

    getMyFileRecords(beforeUid, order, count, successCB, failCB) {
        protoProxy.invokeAsync('getMyFiles', Long.fromValue(beforeUid).toString(), order, count, (frsStr) => {
            let frs = JSON.parse(frsStr);
            let fileRecords = [];
            frs.forEach(fr => {
                fileRecords.push(this._objStrToFileRecordObj(fr));
            })
            successCB && successCB(fileRecords);
        }, (errorCode) => {
            failCB && failCB(errorCode);
        });
    }

    deleteFileRecord(messageUid, successCB, failCB) {
        protoProxy.invokeAsync('deleteFileRecord', Long.fromValue(messageUid).toString(), () => {
            successCB && successCB();
        }, (errorCode) => {
            failCB && failCB(errorCode);
        });
    }

    async clearMessages(conversation) {
        protoProxy.invoke('clearMessages', JSON.stringify(conversation));
        let conversationInfo = this.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    async clearUserMessages(userId, startTime, endTime) {
        protoProxy.invoke('clearUserMessages', userId, startTime, endTime);
    }

    async clearRemoteConversationMessages(conversation, successCB, failCB) {
        protoProxy.invokeAsync('clearRemoteConversationMessages', JSON.stringify(conversation),
            () => {
                let conversationInfo = this.getConversationInfo(conversation);
                self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
                successCB && successCB();
            },
            (errorCode) => {
                failCB && failCB(errorCode);
            }
        );
    }

    /**
     * 删除before时间之前的所有消息
     *
     * @param {Conversation} conversation
     * @param {String} before 时间精度到毫秒，字符串格式
     */
    async clearMessagesByTime(conversation, before) {
        protoProxy.invoke('clearMessagesByTime', JSON.stringify(conversation), before);
        let conversationInfo = this.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    clearAllMessages(removeConversation) {
        protoProxy.invoke('clearAllMessages', removeConversation);
    }

    /**
     *
     * @param {Conversation} conversation
     * @param {MessageContent} messageContent
     * @param {number} status
     * @param {boolean} notify 是否触发onReceiveMessage
     * @param {[string]} toUsers
     * @param {Number} serverTime 服务器时间，精度到毫秒
     */
    insertMessage(conversation, messageContent, status, notify = false, toUsers = [], serverTime = 0) {
        let protoMessageContent = messageContent.encode();
        let mStr = protoProxy.invoke('insertMessage', JSON.stringify(conversation), self.userId, JSON.stringify(protoMessageContent), status, notify, toUsers, serverTime);
        return Message.fromProtoMessage(JSON.parse(mStr));
    }


    insertMessageEx(messageUid, conversation, fromUser, messageContent, status, serverTime, localExtra) {
        let protoMessageContent = messageContent.encode();
        let mStr = protoProxy.invoke('insertMessageEx', Long.fromValue(messageUid).toString(), JSON.stringify(conversation), fromUser, JSON.stringify(protoMessageContent), status, serverTime, localExtra);
        return Message.fromProtoMessage(JSON.parse(mStr));
    }

    async updateMessageContent(messageId, messageContent) {
        let protoMessageContent = messageContent.encode();
        protoProxy.invoke('updateMessage', messageId, JSON.stringify(protoMessageContent));
    }

    async updateMessageStatus(messageId, status) {
        protoProxy.invoke('updateMessageStatus', messageId, status);
    }

    async uploadMedia(fileName, fileOrData, mediaType, successCB, failCB, progressCB) {
        // var data = file.slile(0, file.size);
        if (this.isTcpShortLink() && !this.isSupportBigFilesUpload()) {
            console.error('TCP短连接不支持内置对象存储，请把对象存储切换到其他类型')
            failCB && failCB(-1);
            return;
        }
        // dataUri
        if (typeof fileOrData === 'string' && fileOrData.indexOf("base64,") >= 0) {
            fileOrData = fileOrData.substring(fileOrData.indexOf(',') + 1);
        }
        if (this.isTcpShortLink() || this.isSupportBigFilesUpload()) {
            let file;
            if (typeof fileOrData === 'string') {
                const byteCharacters = atob(fileOrData);
                const byteArray = new Uint8Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteArray[i] = byteCharacters.charCodeAt(i);
                }
                file = new Blob([new Uint8Array(byteArray, 0, byteArray.byteLength)]);
            } else {
                file = fileOrData;
            }
            this._uploadFile(null, file, mediaType, progressCB, successCB, failCB);
        } else {
            // file
            if (fileOrData.path) {
                fileOrData = await fs.readFile(fileOrData.path, {encoding: 'base64'});
            }
            protoProxy.invokeAsync('uploadMedia', fileName, fileOrData, mediaType,
                (remoteUrl) => {
                    if (successCB) {
                        successCB(remoteUrl);
                    }
                },
                (errorCode) => {
                    if (failCB) {
                        failCB(errorCode);
                    }
                },
                (current, total) => {
                    if (progressCB) {
                        progressCB(current, total);
                    }
                });
        }
    }

    sendConferenceRequest(sessionId, roomId, request, data, advance, callback) {
        protoProxy.invokeAsync('sendConferenceRequest', '' + sessionId, roomId, request, data,
            (resp) => {
                callback && callback(0, resp);
            },
            (errorCode) => {
                callback && callback(errorCode, null)
            }, advance === true);
    }

    searchFiles(keyword, conversation, fromUser, beforeMessageId, order, count, successCB, failCB) {
        protoProxy.invokeAsync('searchFiles', keyword, conversation ? JSON.stringify(conversation) : '', fromUser, Long.fromValue(beforeMessageId).toString(), order, count,
            (files) => {
                let frs = JSON.parse(files);

                let fileRecords = [];
                frs.forEach(fr => {
                    fileRecords.push(this._objStrToFileRecordObj(fr));
                })
                successCB && successCB(fileRecords);
            },
            (errorCode) => {
                failCB && failCB(errorCode);
            })
    }

    searchMyFiles(keyword, beforeMessageUid, order, count, successCB, failCB) {
        protoProxy.invokeAsync('searchMyFiles', keyword, Long.fromValue(beforeMessageUid).toString(), order, count,
            (files) => {
                let frs = JSON.parse(files);

                let fileRecords = [];
                frs.forEach(fr => {
                    fileRecords.push(this._objStrToFileRecordObj(fr));
                })
                successCB && successCB(fileRecords);
            },
            (errorCode) => {
                failCB && failCB(errorCode);
            });
    }

    getHost() {
        return protoProxy.invoke('getHost');
    }

    async createSecretChat(userId, successCB, failCB) {
        protoProxy.invokeAsync('createSecretChat', userId,
            (targetId, line) => {
                if (successCB) {
                    successCB(targetId, line);
                }
            },
            (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            }
        );
    }

    async destroySecretChat(targetId, successCB, failCB) {
        protoProxy.invokeAsync('destroySecretChat', targetId,
            () => {
                if (successCB) {
                    successCB();
                }
            },
            (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            }
        );
    }

    getSecretChatInfo(targetId) {
        let secretChatInfoStr = protoProxy.invoke('getSecretChatInfo', targetId);
        if (!secretChatInfoStr) {
            return null;
        }
        let obj = Object.assign(new SecretChatInfo(), JSON.parse(secretChatInfoStr));
        obj.targetId = targetId;
        return obj;
    }

    getAuthCode(appId, appType, host, successCB, failCB) {
        protoProxy.invokeAsync('getAuthCode', appId, appType, host, (authCode) => {
            successCB && successCB(authCode);
        }, (err) => {
            failCB && failCB(err);
        });
    }

    //public void configApplication(String appId, int appType, long timestamp, String nonceStr, String signature, GeneralCallback callback) {
    configApplication(appId, appType, timestamp, nonceStr, signature, successCB, failCB) {
        protoProxy.invokeAsync('configApplication', appId, appType, timestamp, nonceStr, signature, () => {
            successCB && successCB();
        }, (err) => {
            failCB && failCB(err);
        });
    }

    //byte[]
    decodeSecretChatMediaData(targetId, mediaDatas) {
        return protoProxy.invoke('decodeSecretChatMediaData', targetId, mediaDatas);
    }

    //byte[]
    encodeSecretChatMediaData(targetId, mediaDatas) {
        return protoProxy.invoke('encodeSecretChatMediaData', targetId, mediaDatas);
    }

    setSecretChatBurnTime(targetId, ms) {
        protoProxy.invoke('setSecretChatBurnTime', targetId, ms);
    }

    isEnableSecretChat() {
        return protoProxy.invoke('isEnableSecretChat');
    }

    getAppPath() {
        return protoProxy.invoke('getAppPath');
    }

    isUserEnableSecretChat() {
        return protoProxy.invoke('isUserEnableSecretChat');
    }

    async setUserEnableSecretChat(enable, successCB, failCB) {
        protoProxy.invoke('setUserEnableSecretChat', enable, () => {
            successCB && successCB();
        }, (errorCode) => {
            failCB && failCB(errorCode);
        });
    }

    beginTransaction() {
        return protoProxy.invoke('beginTransaction');
    }

    commitTransaction() {
        return protoProxy.invoke('commitTransaction');
    }

    rollbackTransaction() {
        return protoProxy.invoke('roolbackTransaction');
    }

    requireLock(lockId, duration, successCB, failCB) {
        protoProxy.invokeAsync('requireLock', lockId, duration, () => {
            successCB && successCB();
        }, (errorCode) => {
            failCB && failCB(errorCode);
        })
    }

    releaseLock(lockId, successCB, failCB) {
        protoProxy.invokeAsync('releaseLock', lockId, () => {
            successCB && successCB();
        }, errorCode => {
            failCB && failCB(errorCode);
        })
    }

    _setupEventListeners() {
        protoProxy.setProtoEventListener('connectionStatus', (status) => {
            self.onConnectionChanged(status);
            // TODO 已经支持了，这儿不用转了，移除相关代码
            // this._forwardToOtherWindow('connectionStatus', status)
        });
        protoProxy.setProtoEventListener('connectToServer', (host, ip, port) => {
            self.onConnectToServer(host, ip, port)
        });
        //proto.setReceiveMessageListener(self.onReceiveMessage, self.onRecallMessage, self.onDeleteRemoteMessage, self.onUserReceivedMessage, self.onUserReadedMessage);
        protoProxy.setProtoEventListener('onReceiveMessage', (messages, hasMore) => {
            // onReceiveMessage
            self.onReceiveMessage(messages, hasMore)

        });
        protoProxy.setProtoEventListener('onSendMessage', (message) => {
            let msg = Message.fromProtoMessage(JSON.parse(message));
            self.eventEmitter.emit(EventType.SendMessage, msg);
        });
        protoProxy.setProtoEventListener('onMessageStatusUpdate', (message) => {
            let msg = Message.fromProtoMessage(JSON.parse(message));
            self.eventEmitter.emit(EventType.MessageStatusUpdate, msg);
        });
        protoProxy.setProtoEventListener('onRecallMessage', (operatorUid, messageUid) => {
            // onRecallMessage
            self.onRecallMessage(operatorUid, messageUid);

        });
        protoProxy.setProtoEventListener('onDeleteRemoteMessage', (messageUid) => {
            // onDeleteRemoteMessage
            self.onDeleteRemoteMessage(messageUid);

        });
        protoProxy.setProtoEventListener('onUserReceivedMessage', (receivedMapStr) => {
            // onUserReceivedMessage
            self.onUserReceivedMessage(receivedMapStr)

        });
        protoProxy.setProtoEventListener('onUserReadedMessage', (readedMapStr) => {
            // onUserReadedMessage
            self.onUserReadedMessage(readedMapStr)
        });
        //proto.setConferenceEventListener(self.onConferenceEvent);
        protoProxy.setProtoEventListener('conferenceEvent', (event) => {
            self.onConferenceEvent(event);
        });
        // proto.setOnlineEventListener(self.onOnlineEvent);
        protoProxy.setProtoEventListener('onlineEvent', (event) => {
            self.onOnlineEvent(event);
        });
        // proto.setUserInfoUpdateListener(self.onUserInfoUpdate);
        protoProxy.setProtoEventListener('userInfoUpdate', (userIds) => {
            self.onUserInfoUpdate(userIds);
        });

        // proto.setFriendUpdateListener(self.onFriendListUpdate);
        protoProxy.setProtoEventListener('friendUpdate', (friendListIds) => {
            self.onFriendListUpdate(friendListIds)
        });

        // proto.setFriendRequestListener(self.onFriendRequestUpdate);
        protoProxy.setProtoEventListener('friendRequestUpdate', (newRequests = '[]') => {
            self.onFriendRequestUpdate(newRequests);
        });
        // proto.setGroupInfoUpdateListener(self.onGroupInfoUpdate);
        protoProxy.setProtoEventListener('groupInfoUpdate', (groupListIds) => {
            self.onGroupInfoUpdate(groupListIds)
        });
        // proto.setSettingUpdateListener(self.onSettingUpdate);
        protoProxy.setProtoEventListener('settingUpdate', () => {
            self.onSettingUpdate();
        });
        // proto.setChannelInfoUpdateListener(self.onChannelInfoUpdate);
        protoProxy.setProtoEventListener('channelInfoUpdate', (channelListIds) => {
            self.onChannelInfoUpdate(channelListIds);
        });
        // proto.setGroupMemberUpdateListener(self.onGroupMemberUpdateListener);
        protoProxy.setProtoEventListener('groupMemberUpdate', (groupId, groupMembersStr) => {
            self.onGroupMemberUpdateListener(groupId, groupMembersStr);
        });
        protoProxy.setProtoEventListener('secretChatStateChange', (targetId) => {
            self.onSecretChatStateChangedListener(targetId);
        });
        protoProxy.setProtoEventListener('secretMessageStartBurn', (targetId, playedMessageId) => {
            self.onSecretMessageStartBurningListener(targetId, playedMessageId);
        });
        protoProxy.setProtoEventListener('secretMessageBurned', (messageIds) => {
            self.onSecretMessageBurnedListener(messageIds);
        });
    }

    _getLatestLogFilePath() {
        let appPath = this.getAppPath();
        const fileNames = require('fs').readdirSync(appPath)
        const logFiles = fileNames.filter(fn => fn.endsWith(".xlog")).sort((a, b) => a > b ? 1 : -1)
        return logFiles.length > 0 ? appPath + '/' + logFiles[logFiles.length - 1] : null;
    }

    // 预加载数据
    // 拉取会话相关用户、群信息
    // 自己的用户信息
    // 获取所有好友、好友请求的用户信息
    _preloadDefaultData() {
        let requests = self.getIncommingFriendRequest()
        let userIdSet = new Set();
        requests.forEach(fr => {
            userIdSet.add(fr.target);
        });
        requests = self.getOutgoingFriendRequest()
        requests.forEach(fr => {
            userIdSet.add(fr.target);
        });

        let friendIds = self.getMyFriendList(false);
        friendIds.forEach(uid => userIdSet.add(uid));

        let conversationInfoList = self.getConversationList([0, 1, 3], [0, 1, 2]);
        let groupIdIds = [];
        let channelIds = [];
        conversationInfoList.forEach(info => {
            if (info.conversation.type === ConversationType.Single) {
                userIdSet.add(info.conversation.target);
            } else if (info.conversation.type === ConversationType.Group) {
                groupIdIds.push(info.conversation.target);
            } else if (info.conversation.type === ConversationType.Channel) {
                channelIds.push(info.conversation.target)
            }
            if (info.lastMessage && info.lastMessage.from) {
                userIdSet.add(info.lastMessage.from);
            }
        })
        let uids = Array.from(userIdSet);
        console.log('to preload userIds', uids, userIdSet)
        for (let i = 0; i < uids.length / 2000; i++) {
            self.getUserInfos(uids.slice(2000 * i, (i + 1) * 2000), '');
            console.log('to preload', uids.slice(2000 * i, (i + 1) * 2000))
        }

        console.log('to preload groupIds', groupIdIds)
        self.getGroupInfos(groupIdIds, false)
        groupIdIds.forEach(groupId => {
            self.getGroupMembers(groupId, false);
        })
        channelIds.forEach(channelId => {
            self.getChannelInfo(channelId)
        })

        let estimatedTime = 0;
        // 每 2000 人 5 秒
        estimatedTime += Math.round(uids.length / 2000) * 4
        // 每 10 个群 2 秒
        estimatedTime += Math.round(groupIdIds.length / 10) * 2

        return estimatedTime * 1000;
    }

    _preloadGroupMemberUserInfos(memberIds) {
        for (let i = 0; i < memberIds.length / 2000; i++) {
            self.getUserInfos(memberIds.slice(2000 * i, (i + 1) * 2000), '');
            console.log('to preload', memberIds.slice(2000 * i, (i + 1) * 2000))
        }
    }

    _getStore() {
        console.log('not support')
        return null;
    }

    _getContentType(mediaType, fileName) {
        let contentType = "application/octet-stream";
        if (fileName) {
            let suffix = fileName.substring(fileName.lastIndexOf('.') + 1)
            if (suffix === "jpg" || suffix === "jpeg") {
                contentType = "image/jpeg";
            } else if (suffix === "gif") {
                contentType = "image/gif";
            } else if (suffix === "png") {
                contentType = "image/png";
            } else if (suffix === "mp3") {
                contentType = "audio/mpeg";
            } else if (suffix === "mp4") {
                contentType = "video/mp4";
            } else if (suffix === "doc") {
                contentType = "application/vnd.ms-word";
            } else if (suffix === "docx") {
                contentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
            } else if (suffix === "xls") {
                contentType = "application/vnd.ms-xls";
            } else if (suffix === "xlsx") {
                contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            } else if (suffix === "ppt") {
                contentType = "application/vnd.ms-powerpoint";
            } else if (suffix === "pptx") {
                contentType = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
            } else if (suffix === "pps") {
                contentType = "application/vnd.ms-powerpoint";
            } else if (suffix === "pdf") {
                contentType = "application/pdf";
            } else if (suffix === "xml") {
                contentType = "application/vnd.ms-xml";
            } else {
                // return "application/octet-stream";
            }
        } else {
            if (mediaType === 1) {
                contentType = "image/jpeg";
            } else if (mediaType === 2) {
                contentType = "audio/amr";
            } else if (mediaType === 3) {
                contentType = "video/mp4";
            }
        }
        return contentType;
    }
}

const self = new WfcImpl();
export default self;
